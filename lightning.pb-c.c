/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: lightning.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "lightning.pb-c.h"
void   sha256_hash__init
                     (Sha256Hash         *message)
{
  static Sha256Hash init_value = SHA256_HASH__INIT;
  *message = init_value;
}
size_t sha256_hash__get_packed_size
                     (const Sha256Hash *message)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t sha256_hash__pack
                     (const Sha256Hash *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t sha256_hash__pack_to_buffer
                     (const Sha256Hash *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Sha256Hash *
       sha256_hash__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Sha256Hash *)
     protobuf_c_message_unpack (&sha256_hash__descriptor,
                                allocator, len, data);
}
void   sha256_hash__free_unpacked
                     (Sha256Hash *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &sha256_hash__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   bitcoin_output_id__init
                     (BitcoinOutputId         *message)
{
  static BitcoinOutputId init_value = BITCOIN_OUTPUT_ID__INIT;
  *message = init_value;
}
size_t bitcoin_output_id__get_packed_size
                     (const BitcoinOutputId *message)
{
  assert(message->base.descriptor == &bitcoin_output_id__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t bitcoin_output_id__pack
                     (const BitcoinOutputId *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &bitcoin_output_id__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t bitcoin_output_id__pack_to_buffer
                     (const BitcoinOutputId *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &bitcoin_output_id__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
BitcoinOutputId *
       bitcoin_output_id__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (BitcoinOutputId *)
     protobuf_c_message_unpack (&bitcoin_output_id__descriptor,
                                allocator, len, data);
}
void   bitcoin_output_id__free_unpacked
                     (BitcoinOutputId *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &bitcoin_output_id__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   bitcoin_output__init
                     (BitcoinOutput         *message)
{
  static BitcoinOutput init_value = BITCOIN_OUTPUT__INIT;
  *message = init_value;
}
size_t bitcoin_output__get_packed_size
                     (const BitcoinOutput *message)
{
  assert(message->base.descriptor == &bitcoin_output__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t bitcoin_output__pack
                     (const BitcoinOutput *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &bitcoin_output__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t bitcoin_output__pack_to_buffer
                     (const BitcoinOutput *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &bitcoin_output__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
BitcoinOutput *
       bitcoin_output__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (BitcoinOutput *)
     protobuf_c_message_unpack (&bitcoin_output__descriptor,
                                allocator, len, data);
}
void   bitcoin_output__free_unpacked
                     (BitcoinOutput *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &bitcoin_output__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   bitcoin_signature__init
                     (BitcoinSignature         *message)
{
  static BitcoinSignature init_value = BITCOIN_SIGNATURE__INIT;
  *message = init_value;
}
size_t bitcoin_signature__get_packed_size
                     (const BitcoinSignature *message)
{
  assert(message->base.descriptor == &bitcoin_signature__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t bitcoin_signature__pack
                     (const BitcoinSignature *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &bitcoin_signature__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t bitcoin_signature__pack_to_buffer
                     (const BitcoinSignature *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &bitcoin_signature__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
BitcoinSignature *
       bitcoin_signature__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (BitcoinSignature *)
     protobuf_c_message_unpack (&bitcoin_signature__descriptor,
                                allocator, len, data);
}
void   bitcoin_signature__free_unpacked
                     (BitcoinSignature *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &bitcoin_signature__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   anchor__init
                     (Anchor         *message)
{
  static Anchor init_value = ANCHOR__INIT;
  *message = init_value;
}
size_t anchor__get_packed_size
                     (const Anchor *message)
{
  assert(message->base.descriptor == &anchor__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t anchor__pack
                     (const Anchor *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &anchor__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t anchor__pack_to_buffer
                     (const Anchor *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &anchor__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Anchor *
       anchor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Anchor *)
     protobuf_c_message_unpack (&anchor__descriptor,
                                allocator, len, data);
}
void   anchor__free_unpacked
                     (Anchor *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &anchor__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_channel__init
                     (OpenChannel         *message)
{
  static OpenChannel init_value = OPEN_CHANNEL__INIT;
  *message = init_value;
}
size_t open_channel__get_packed_size
                     (const OpenChannel *message)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_channel__pack
                     (const OpenChannel *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_channel__pack_to_buffer
                     (const OpenChannel *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenChannel *
       open_channel__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenChannel *)
     protobuf_c_message_unpack (&open_channel__descriptor,
                                allocator, len, data);
}
void   open_channel__free_unpacked
                     (OpenChannel *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_channel__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_commit_sig__init
                     (OpenCommitSig         *message)
{
  static OpenCommitSig init_value = OPEN_COMMIT_SIG__INIT;
  *message = init_value;
}
size_t open_commit_sig__get_packed_size
                     (const OpenCommitSig *message)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_commit_sig__pack
                     (const OpenCommitSig *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_commit_sig__pack_to_buffer
                     (const OpenCommitSig *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenCommitSig *
       open_commit_sig__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenCommitSig *)
     protobuf_c_message_unpack (&open_commit_sig__descriptor,
                                allocator, len, data);
}
void   open_commit_sig__free_unpacked
                     (OpenCommitSig *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_commit_sig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_anchor_sig__init
                     (OpenAnchorSig         *message)
{
  static OpenAnchorSig init_value = OPEN_ANCHOR_SIG__INIT;
  *message = init_value;
}
size_t open_anchor_sig__get_packed_size
                     (const OpenAnchorSig *message)
{
  assert(message->base.descriptor == &open_anchor_sig__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_anchor_sig__pack
                     (const OpenAnchorSig *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_anchor_sig__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_anchor_sig__pack_to_buffer
                     (const OpenAnchorSig *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_anchor_sig__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenAnchorSig *
       open_anchor_sig__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenAnchorSig *)
     protobuf_c_message_unpack (&open_anchor_sig__descriptor,
                                allocator, len, data);
}
void   open_anchor_sig__free_unpacked
                     (OpenAnchorSig *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_anchor_sig__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   open_complete__init
                     (OpenComplete         *message)
{
  static OpenComplete init_value = OPEN_COMPLETE__INIT;
  *message = init_value;
}
size_t open_complete__get_packed_size
                     (const OpenComplete *message)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t open_complete__pack
                     (const OpenComplete *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t open_complete__pack_to_buffer
                     (const OpenComplete *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
OpenComplete *
       open_complete__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (OpenComplete *)
     protobuf_c_message_unpack (&open_complete__descriptor,
                                allocator, len, data);
}
void   open_complete__free_unpacked
                     (OpenComplete *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &open_complete__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update__init
                     (Update         *message)
{
  static Update init_value = UPDATE__INIT;
  *message = init_value;
}
size_t update__get_packed_size
                     (const Update *message)
{
  assert(message->base.descriptor == &update__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update__pack
                     (const Update *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update__pack_to_buffer
                     (const Update *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Update *
       update__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Update *)
     protobuf_c_message_unpack (&update__descriptor,
                                allocator, len, data);
}
void   update__free_unpacked
                     (Update *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_accept__init
                     (UpdateAccept         *message)
{
  static UpdateAccept init_value = UPDATE_ACCEPT__INIT;
  *message = init_value;
}
size_t update_accept__get_packed_size
                     (const UpdateAccept *message)
{
  assert(message->base.descriptor == &update_accept__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_accept__pack
                     (const UpdateAccept *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_accept__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_accept__pack_to_buffer
                     (const UpdateAccept *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_accept__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateAccept *
       update_accept__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateAccept *)
     protobuf_c_message_unpack (&update_accept__descriptor,
                                allocator, len, data);
}
void   update_accept__free_unpacked
                     (UpdateAccept *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_accept__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   update_complete__init
                     (UpdateComplete         *message)
{
  static UpdateComplete init_value = UPDATE_COMPLETE__INIT;
  *message = init_value;
}
size_t update_complete__get_packed_size
                     (const UpdateComplete *message)
{
  assert(message->base.descriptor == &update_complete__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t update_complete__pack
                     (const UpdateComplete *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &update_complete__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t update_complete__pack_to_buffer
                     (const UpdateComplete *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &update_complete__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
UpdateComplete *
       update_complete__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (UpdateComplete *)
     protobuf_c_message_unpack (&update_complete__descriptor,
                                allocator, len, data);
}
void   update_complete__free_unpacked
                     (UpdateComplete *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &update_complete__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   new_anchor__init
                     (NewAnchor         *message)
{
  static NewAnchor init_value = NEW_ANCHOR__INIT;
  *message = init_value;
}
size_t new_anchor__get_packed_size
                     (const NewAnchor *message)
{
  assert(message->base.descriptor == &new_anchor__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t new_anchor__pack
                     (const NewAnchor *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &new_anchor__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t new_anchor__pack_to_buffer
                     (const NewAnchor *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &new_anchor__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NewAnchor *
       new_anchor__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NewAnchor *)
     protobuf_c_message_unpack (&new_anchor__descriptor,
                                allocator, len, data);
}
void   new_anchor__free_unpacked
                     (NewAnchor *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &new_anchor__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   new_anchor_ack__init
                     (NewAnchorAck         *message)
{
  static NewAnchorAck init_value = NEW_ANCHOR_ACK__INIT;
  *message = init_value;
}
size_t new_anchor_ack__get_packed_size
                     (const NewAnchorAck *message)
{
  assert(message->base.descriptor == &new_anchor_ack__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t new_anchor_ack__pack
                     (const NewAnchorAck *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &new_anchor_ack__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t new_anchor_ack__pack_to_buffer
                     (const NewAnchorAck *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &new_anchor_ack__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NewAnchorAck *
       new_anchor_ack__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NewAnchorAck *)
     protobuf_c_message_unpack (&new_anchor_ack__descriptor,
                                allocator, len, data);
}
void   new_anchor_ack__free_unpacked
                     (NewAnchorAck *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &new_anchor_ack__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   new_anchor_accept__init
                     (NewAnchorAccept         *message)
{
  static NewAnchorAccept init_value = NEW_ANCHOR_ACCEPT__INIT;
  *message = init_value;
}
size_t new_anchor_accept__get_packed_size
                     (const NewAnchorAccept *message)
{
  assert(message->base.descriptor == &new_anchor_accept__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t new_anchor_accept__pack
                     (const NewAnchorAccept *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &new_anchor_accept__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t new_anchor_accept__pack_to_buffer
                     (const NewAnchorAccept *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &new_anchor_accept__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NewAnchorAccept *
       new_anchor_accept__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NewAnchorAccept *)
     protobuf_c_message_unpack (&new_anchor_accept__descriptor,
                                allocator, len, data);
}
void   new_anchor_accept__free_unpacked
                     (NewAnchorAccept *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &new_anchor_accept__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   new_anchor_complete__init
                     (NewAnchorComplete         *message)
{
  static NewAnchorComplete init_value = NEW_ANCHOR_COMPLETE__INIT;
  *message = init_value;
}
size_t new_anchor_complete__get_packed_size
                     (const NewAnchorComplete *message)
{
  assert(message->base.descriptor == &new_anchor_complete__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t new_anchor_complete__pack
                     (const NewAnchorComplete *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &new_anchor_complete__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t new_anchor_complete__pack_to_buffer
                     (const NewAnchorComplete *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &new_anchor_complete__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
NewAnchorComplete *
       new_anchor_complete__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (NewAnchorComplete *)
     protobuf_c_message_unpack (&new_anchor_complete__descriptor,
                                allocator, len, data);
}
void   new_anchor_complete__free_unpacked
                     (NewAnchorComplete *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &new_anchor_complete__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   close_channel__init
                     (CloseChannel         *message)
{
  static CloseChannel init_value = CLOSE_CHANNEL__INIT;
  *message = init_value;
}
size_t close_channel__get_packed_size
                     (const CloseChannel *message)
{
  assert(message->base.descriptor == &close_channel__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t close_channel__pack
                     (const CloseChannel *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &close_channel__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t close_channel__pack_to_buffer
                     (const CloseChannel *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &close_channel__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CloseChannel *
       close_channel__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CloseChannel *)
     protobuf_c_message_unpack (&close_channel__descriptor,
                                allocator, len, data);
}
void   close_channel__free_unpacked
                     (CloseChannel *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &close_channel__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   close_channel_complete__init
                     (CloseChannelComplete         *message)
{
  static CloseChannelComplete init_value = CLOSE_CHANNEL_COMPLETE__INIT;
  *message = init_value;
}
size_t close_channel_complete__get_packed_size
                     (const CloseChannelComplete *message)
{
  assert(message->base.descriptor == &close_channel_complete__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t close_channel_complete__pack
                     (const CloseChannelComplete *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &close_channel_complete__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t close_channel_complete__pack_to_buffer
                     (const CloseChannelComplete *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &close_channel_complete__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
CloseChannelComplete *
       close_channel_complete__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (CloseChannelComplete *)
     protobuf_c_message_unpack (&close_channel_complete__descriptor,
                                allocator, len, data);
}
void   close_channel_complete__free_unpacked
                     (CloseChannelComplete *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &close_channel_complete__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   error__init
                     (Error         *message)
{
  static Error init_value = ERROR__INIT;
  *message = init_value;
}
size_t error__get_packed_size
                     (const Error *message)
{
  assert(message->base.descriptor == &error__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t error__pack
                     (const Error *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &error__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t error__pack_to_buffer
                     (const Error *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &error__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Error *
       error__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Error *)
     protobuf_c_message_unpack (&error__descriptor,
                                allocator, len, data);
}
void   error__free_unpacked
                     (Error *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &error__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
void   pkt__init
                     (Pkt         *message)
{
  static Pkt init_value = PKT__INIT;
  *message = init_value;
}
size_t pkt__get_packed_size
                     (const Pkt *message)
{
  assert(message->base.descriptor == &pkt__descriptor);
  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
}
size_t pkt__pack
                     (const Pkt *message,
                      uint8_t       *out)
{
  assert(message->base.descriptor == &pkt__descriptor);
  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
}
size_t pkt__pack_to_buffer
                     (const Pkt *message,
                      ProtobufCBuffer *buffer)
{
  assert(message->base.descriptor == &pkt__descriptor);
  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
}
Pkt *
       pkt__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data)
{
  return (Pkt *)
     protobuf_c_message_unpack (&pkt__descriptor,
                                allocator, len, data);
}
void   pkt__free_unpacked
                     (Pkt *message,
                      ProtobufCAllocator *allocator)
{
  assert(message->base.descriptor == &pkt__descriptor);
  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
}
static const ProtobufCFieldDescriptor sha256_hash__field_descriptors[4] =
{
  {
    "a",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, a),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "b",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, b),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "c",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, c),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "d",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_FIXED64,
    0,   /* quantifier_offset */
    offsetof(Sha256Hash, d),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned sha256_hash__field_indices_by_name[] = {
  0,   /* field[0] = a */
  1,   /* field[1] = b */
  2,   /* field[2] = c */
  3,   /* field[3] = d */
};
static const ProtobufCIntRange sha256_hash__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor sha256_hash__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "sha256_hash",
  "Sha256Hash",
  "Sha256Hash",
  "",
  sizeof(Sha256Hash),
  4,
  sha256_hash__field_descriptors,
  sha256_hash__field_indices_by_name,
  1,  sha256_hash__number_ranges,
  (ProtobufCMessageInit) sha256_hash__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor bitcoin_output_id__field_descriptors[2] =
{
  {
    "txid",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(BitcoinOutputId, txid),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "output",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(BitcoinOutputId, output),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned bitcoin_output_id__field_indices_by_name[] = {
  1,   /* field[1] = output */
  0,   /* field[0] = txid */
};
static const ProtobufCIntRange bitcoin_output_id__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor bitcoin_output_id__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "bitcoin_output_id",
  "BitcoinOutputId",
  "BitcoinOutputId",
  "",
  sizeof(BitcoinOutputId),
  2,
  bitcoin_output_id__field_descriptors,
  bitcoin_output_id__field_indices_by_name,
  1,  bitcoin_output_id__number_ranges,
  (ProtobufCMessageInit) bitcoin_output_id__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor bitcoin_output__field_descriptors[2] =
{
  {
    "amount",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(BitcoinOutput, amount),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "script",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(BitcoinOutput, script),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned bitcoin_output__field_indices_by_name[] = {
  0,   /* field[0] = amount */
  1,   /* field[1] = script */
};
static const ProtobufCIntRange bitcoin_output__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 2 }
};
const ProtobufCMessageDescriptor bitcoin_output__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "bitcoin_output",
  "BitcoinOutput",
  "BitcoinOutput",
  "",
  sizeof(BitcoinOutput),
  2,
  bitcoin_output__field_descriptors,
  bitcoin_output__field_indices_by_name,
  1,  bitcoin_output__number_ranges,
  (ProtobufCMessageInit) bitcoin_output__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor bitcoin_signature__field_descriptors[1] =
{
  {
    "der_then_sigtype",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(BitcoinSignature, der_then_sigtype),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned bitcoin_signature__field_indices_by_name[] = {
  0,   /* field[0] = der_then_sigtype */
};
static const ProtobufCIntRange bitcoin_signature__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor bitcoin_signature__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "bitcoin_signature",
  "BitcoinSignature",
  "BitcoinSignature",
  "",
  sizeof(BitcoinSignature),
  1,
  bitcoin_signature__field_descriptors,
  bitcoin_signature__field_indices_by_name,
  1,  bitcoin_signature__number_ranges,
  (ProtobufCMessageInit) bitcoin_signature__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor anchor__field_descriptors[4] =
{
  {
    "inputs",
    1,
    PROTOBUF_C_LABEL_REPEATED,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Anchor, n_inputs),
    offsetof(Anchor, inputs),
    &bitcoin_output_id__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "anchor_change",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Anchor, anchor_change),
    &bitcoin_output__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "fee",
    8,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(Anchor, fee),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "min_confirms",
    10,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(Anchor, min_confirms),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned anchor__field_indices_by_name[] = {
  1,   /* field[1] = anchor_change */
  2,   /* field[2] = fee */
  0,   /* field[0] = inputs */
  3,   /* field[3] = min_confirms */
};
static const ProtobufCIntRange anchor__number_ranges[3 + 1] =
{
  { 1, 0 },
  { 8, 2 },
  { 10, 3 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor anchor__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "anchor",
  "Anchor",
  "Anchor",
  "",
  sizeof(Anchor),
  4,
  anchor__field_descriptors,
  anchor__field_indices_by_name,
  3,  anchor__number_ranges,
  (ProtobufCMessageInit) anchor__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_channel__field_descriptors[8] =
{
  {
    "seed",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, seed),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "locktime_seconds",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(OpenChannel, locktime_case),
    offsetof(OpenChannel, locktime_seconds),
    NULL,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "locktime_blocks",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_UINT32,
    offsetof(OpenChannel, locktime_case),
    offsetof(OpenChannel, locktime_blocks),
    NULL,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_hash",
    4,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, revocation_hash),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "script_to_me",
    5,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_BYTES,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, script_to_me),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "commitment_fee",
    6,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT64,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, commitment_fee),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "anchor",
    7,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, anchor),
    &anchor__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "tx_version",
    8,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_UINT32,
    0,   /* quantifier_offset */
    offsetof(OpenChannel, tx_version),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_channel__field_indices_by_name[] = {
  6,   /* field[6] = anchor */
  5,   /* field[5] = commitment_fee */
  2,   /* field[2] = locktime_blocks */
  1,   /* field[1] = locktime_seconds */
  3,   /* field[3] = revocation_hash */
  4,   /* field[4] = script_to_me */
  0,   /* field[0] = seed */
  7,   /* field[7] = tx_version */
};
static const ProtobufCIntRange open_channel__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 8 }
};
const ProtobufCMessageDescriptor open_channel__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_channel",
  "OpenChannel",
  "OpenChannel",
  "",
  sizeof(OpenChannel),
  8,
  open_channel__field_descriptors,
  open_channel__field_indices_by_name,
  1,  open_channel__number_ranges,
  (ProtobufCMessageInit) open_channel__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_commit_sig__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenCommitSig, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_commit_sig__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange open_commit_sig__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor open_commit_sig__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_commit_sig",
  "OpenCommitSig",
  "OpenCommitSig",
  "",
  sizeof(OpenCommitSig),
  1,
  open_commit_sig__field_descriptors,
  open_commit_sig__field_indices_by_name,
  1,  open_commit_sig__number_ranges,
  (ProtobufCMessageInit) open_commit_sig__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_anchor_sig__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenAnchorSig, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_anchor_sig__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange open_anchor_sig__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor open_anchor_sig__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_anchor_sig",
  "OpenAnchorSig",
  "OpenAnchorSig",
  "",
  sizeof(OpenAnchorSig),
  1,
  open_anchor_sig__field_descriptors,
  open_anchor_sig__field_indices_by_name,
  1,  open_anchor_sig__number_ranges,
  (ProtobufCMessageInit) open_anchor_sig__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor open_complete__field_descriptors[1] =
{
  {
    "blockid",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(OpenComplete, blockid),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned open_complete__field_indices_by_name[] = {
  0,   /* field[0] = blockid */
};
static const ProtobufCIntRange open_complete__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor open_complete__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "open_complete",
  "OpenComplete",
  "OpenComplete",
  "",
  sizeof(OpenComplete),
  1,
  open_complete__field_descriptors,
  open_complete__field_indices_by_name,
  1,  open_complete__number_ranges,
  (ProtobufCMessageInit) open_complete__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update__field_descriptors[4] =
{
  {
    "revocation_hash",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Update, revocation_hash),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "delta",
    2,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_SINT64,
    0,   /* quantifier_offset */
    offsetof(Update, delta),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "sig",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Update, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "old_anchor_sig",
    4,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(Update, old_anchor_sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update__field_indices_by_name[] = {
  1,   /* field[1] = delta */
  3,   /* field[3] = old_anchor_sig */
  0,   /* field[0] = revocation_hash */
  2,   /* field[2] = sig */
};
static const ProtobufCIntRange update__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 4 }
};
const ProtobufCMessageDescriptor update__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update",
  "Update",
  "Update",
  "",
  sizeof(Update),
  4,
  update__field_descriptors,
  update__field_indices_by_name,
  1,  update__number_ranges,
  (ProtobufCMessageInit) update__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_accept__field_descriptors[3] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateAccept, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "old_anchor_sig",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateAccept, old_anchor_sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "revocation_preimage",
    3,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateAccept, revocation_preimage),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_accept__field_indices_by_name[] = {
  1,   /* field[1] = old_anchor_sig */
  2,   /* field[2] = revocation_preimage */
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange update_accept__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 3 }
};
const ProtobufCMessageDescriptor update_accept__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_accept",
  "UpdateAccept",
  "UpdateAccept",
  "",
  sizeof(UpdateAccept),
  3,
  update_accept__field_descriptors,
  update_accept__field_indices_by_name,
  1,  update_accept__number_ranges,
  (ProtobufCMessageInit) update_accept__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor update_complete__field_descriptors[1] =
{
  {
    "revocation_preimage",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(UpdateComplete, revocation_preimage),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned update_complete__field_indices_by_name[] = {
  0,   /* field[0] = revocation_preimage */
};
static const ProtobufCIntRange update_complete__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor update_complete__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "update_complete",
  "UpdateComplete",
  "UpdateComplete",
  "",
  sizeof(UpdateComplete),
  1,
  update_complete__field_descriptors,
  update_complete__field_indices_by_name,
  1,  update_complete__number_ranges,
  (ProtobufCMessageInit) update_complete__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor new_anchor__field_descriptors[1] =
{
  {
    "anchor",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(NewAnchor, anchor),
    &anchor__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned new_anchor__field_indices_by_name[] = {
  0,   /* field[0] = anchor */
};
static const ProtobufCIntRange new_anchor__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor new_anchor__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "new_anchor",
  "NewAnchor",
  "NewAnchor",
  "",
  sizeof(NewAnchor),
  1,
  new_anchor__field_descriptors,
  new_anchor__field_indices_by_name,
  1,  new_anchor__number_ranges,
  (ProtobufCMessageInit) new_anchor__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor new_anchor_ack__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(NewAnchorAck, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned new_anchor_ack__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange new_anchor_ack__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor new_anchor_ack__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "new_anchor_ack",
  "NewAnchorAck",
  "NewAnchorAck",
  "",
  sizeof(NewAnchorAck),
  1,
  new_anchor_ack__field_descriptors,
  new_anchor_ack__field_indices_by_name,
  1,  new_anchor_ack__number_ranges,
  (ProtobufCMessageInit) new_anchor_ack__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor new_anchor_accept__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(NewAnchorAccept, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned new_anchor_accept__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange new_anchor_accept__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor new_anchor_accept__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "new_anchor_accept",
  "NewAnchorAccept",
  "NewAnchorAccept",
  "",
  sizeof(NewAnchorAccept),
  1,
  new_anchor_accept__field_descriptors,
  new_anchor_accept__field_indices_by_name,
  1,  new_anchor_accept__number_ranges,
  (ProtobufCMessageInit) new_anchor_accept__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor new_anchor_complete__field_descriptors[1] =
{
  {
    "revocation_preimage",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(NewAnchorComplete, revocation_preimage),
    &sha256_hash__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned new_anchor_complete__field_indices_by_name[] = {
  0,   /* field[0] = revocation_preimage */
};
static const ProtobufCIntRange new_anchor_complete__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor new_anchor_complete__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "new_anchor_complete",
  "NewAnchorComplete",
  "NewAnchorComplete",
  "",
  sizeof(NewAnchorComplete),
  1,
  new_anchor_complete__field_descriptors,
  new_anchor_complete__field_indices_by_name,
  1,  new_anchor_complete__number_ranges,
  (ProtobufCMessageInit) new_anchor_complete__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor close_channel__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(CloseChannel, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned close_channel__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange close_channel__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor close_channel__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "close_channel",
  "CloseChannel",
  "CloseChannel",
  "",
  sizeof(CloseChannel),
  1,
  close_channel__field_descriptors,
  close_channel__field_indices_by_name,
  1,  close_channel__number_ranges,
  (ProtobufCMessageInit) close_channel__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor close_channel_complete__field_descriptors[1] =
{
  {
    "sig",
    1,
    PROTOBUF_C_LABEL_REQUIRED,
    PROTOBUF_C_TYPE_MESSAGE,
    0,   /* quantifier_offset */
    offsetof(CloseChannelComplete, sig),
    &bitcoin_signature__descriptor,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned close_channel_complete__field_indices_by_name[] = {
  0,   /* field[0] = sig */
};
static const ProtobufCIntRange close_channel_complete__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor close_channel_complete__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "close_channel_complete",
  "CloseChannelComplete",
  "CloseChannelComplete",
  "",
  sizeof(CloseChannelComplete),
  1,
  close_channel_complete__field_descriptors,
  close_channel_complete__field_indices_by_name,
  1,  close_channel_complete__number_ranges,
  (ProtobufCMessageInit) close_channel_complete__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor error__field_descriptors[1] =
{
  {
    "problem",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_STRING,
    0,   /* quantifier_offset */
    offsetof(Error, problem),
    NULL,
    NULL,
    0,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned error__field_indices_by_name[] = {
  0,   /* field[0] = problem */
};
static const ProtobufCIntRange error__number_ranges[1 + 1] =
{
  { 1, 0 },
  { 0, 1 }
};
const ProtobufCMessageDescriptor error__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "error",
  "Error",
  "Error",
  "",
  sizeof(Error),
  1,
  error__field_descriptors,
  error__field_indices_by_name,
  1,  error__number_ranges,
  (ProtobufCMessageInit) error__init,
  NULL,NULL,NULL    /* reserved[123] */
};
static const ProtobufCFieldDescriptor pkt__field_descriptors[14] =
{
  {
    "update",
    1,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update),
    &update__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_accept",
    2,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_accept),
    &update_accept__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "update_complete",
    3,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, update_complete),
    &update_complete__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open",
    201,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open),
    &open_channel__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open_commit_sig",
    202,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open_commit_sig),
    &open_commit_sig__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open_anchor_sig",
    203,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open_anchor_sig),
    &open_anchor_sig__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "open_complete",
    204,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, open_complete),
    &open_complete__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "new_anchor",
    301,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, new_anchor),
    &new_anchor__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "new_anchor_ack",
    302,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, new_anchor_ack),
    &new_anchor_ack__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "new_anchor_accept",
    303,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, new_anchor_accept),
    &new_anchor_accept__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "new_anchor_complete",
    304,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, new_anchor_complete),
    &new_anchor_complete__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "close",
    401,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, close),
    &close_channel__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "close_complete",
    402,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, close_complete),
    &close_channel_complete__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
  {
    "error",
    1000,
    PROTOBUF_C_LABEL_OPTIONAL,
    PROTOBUF_C_TYPE_MESSAGE,
    offsetof(Pkt, pkt_case),
    offsetof(Pkt, error),
    &error__descriptor,
    NULL,
    0 | PROTOBUF_C_FIELD_FLAG_ONEOF,             /* flags */
    0,NULL,NULL    /* reserved1,reserved2, etc */
  },
};
static const unsigned pkt__field_indices_by_name[] = {
  11,   /* field[11] = close */
  12,   /* field[12] = close_complete */
  13,   /* field[13] = error */
  7,   /* field[7] = new_anchor */
  9,   /* field[9] = new_anchor_accept */
  8,   /* field[8] = new_anchor_ack */
  10,   /* field[10] = new_anchor_complete */
  3,   /* field[3] = open */
  5,   /* field[5] = open_anchor_sig */
  4,   /* field[4] = open_commit_sig */
  6,   /* field[6] = open_complete */
  0,   /* field[0] = update */
  1,   /* field[1] = update_accept */
  2,   /* field[2] = update_complete */
};
static const ProtobufCIntRange pkt__number_ranges[5 + 1] =
{
  { 1, 0 },
  { 201, 3 },
  { 301, 7 },
  { 401, 11 },
  { 1000, 13 },
  { 0, 14 }
};
const ProtobufCMessageDescriptor pkt__descriptor =
{
  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
  "pkt",
  "Pkt",
  "Pkt",
  "",
  sizeof(Pkt),
  14,
  pkt__field_descriptors,
  pkt__field_indices_by_name,
  5,  pkt__number_ranges,
  (ProtobufCMessageInit) pkt__init,
  NULL,NULL,NULL    /* reserved[123] */
};
